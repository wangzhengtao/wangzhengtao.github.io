<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <url>%2F2019%2F08%2F21%2FArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList 属性 属性名 所属类 含义 modCount AbstractList 列表结构修改次数 DEFAULT_CAPACITY ArrayList 默认初始容量 EMPTY_ELEMENTDATA ArrayList 空集合返回数据 DEFAULTCAPACITY_EMPTY_ELEMENTDATA ArrayList 空集合返回数据(无参构造函数使用) elementData ArrayList 数据存储缓冲区 size ArrayList 集合大小 ArrayList 构造函数1234567891011121314151617181920212223242526public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 通过上面的构造函数可以看到，ArrayList在初始化的时候，当没有指定大小或指定大小为0的时候，底层数据结构其实是一个空的Object数组，但是属性DEFAULT_CAPACITY 说 默认容量为10，那什么时候开辟的这10个长度的数组呢。我们接着看它的add方法 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 其中有一行 ensureCapacityInternal(size + 1) ，用来确保集合内部容量 123456789101112131415161718192021222324252627282930313233343536373839private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; calculateCapacity 用来计算添加元素后容量，ensureExplicitCapacity 如果计算后的容量大于现有数据缓冲区的长度，则发生扩容 调用 grow方法，扩容至原先容量的1.5倍，当扩容后的容量小于所需容量，扩容至所需容量（发生在默认容量初次添加时） 当扩容后的容量大于最大数组容量（Integer 最大值 - 8）时，如果容量有效且大于最大数组长度，扩容至Integer的最大值]]></content>
      <categories>
        <category>Java源码</category>
        <category>ArrayList</category>
      </categories>
      <tags>
        <tag>Java 源码</tag>
        <tag>List</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 入门]]></title>
    <url>%2F2019%2F05%2F02%2Frabbit-mq-starter%2F</url>
    <content type="text"><![CDATA[RabbitMQ 安装使用单实例安装//待完成 高可用集群//待完成 RabbitMQ 使用 Hello World java 代码实例 添加依赖1implementation 'org.springframework.boot.amqp:spring-rabbit' 1234567891011121314151617181920212223242526272829303132333435363738@Configurationpublic class RabbitQueueConfig &#123; @Bean public Queue helloQueue()&#123; return new Queue("Hello"); &#125;&#125;/***生产者*/@Componentpublic class Producer &#123; @Autowired Queue helloQueue; @Autowired RabbitTemplate rabbitTemplate; public void send(String message)&#123; rabbitTemplate.convertAndSend(helloQueue.getName(),message); &#125;&#125;/***消费者*/import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Componentpublic class Consumer &#123; @RabbitListener(queues = "hello_world") public void process(String message)&#123; System.out.println("receive message "+message); &#125;&#125; Work Queues 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Beanpublic Queue workQueue()&#123; return new Queue("work_queue");&#125;-------------import org.springframework.amqp.core.Queue;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class WorkProducer &#123; @Autowired RabbitTemplate template; @Autowired Queue workQueue; public void send(String message)&#123; template.convertAndSend(workQueue.getName(),message); &#125;&#125;--------------import com.rabbitmq.client.Channel;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;import java.io.IOException;@Componentpublic class WorkConsumer1 &#123; @RabbitListener(queues = "work_queue") public void process(String message, Channel channel) throws IOException &#123; channel.basicQos(1); System.out.println("consumer 1 receive message :"+message); &#125;&#125;------------@Componentpublic class WorkConsumer2 &#123; @RabbitListener(queues = "work_queue") public void process(String message, Channel channel) throws IOException &#123; channel.basicQos(1); System.out.println("consumer 2 receive message :"+message); &#125;&#125;]]></content>
      <categories>
        <category>工具使用</category>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>MQ</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 入门指引]]></title>
    <url>%2F2019%2F04%2F10%2Fredis-starter%2F</url>
    <content type="text"><![CDATA[Redis安装Redis单实例安装 下载源码 1wget http://download.redis.io/releases/redis-5.0.5.tar.gz -P /opt/redis/ 解压并进入目录 12tar xzf redis-5.0.5.tar.gz cd redis-5.0.5 编译到指定目录 1make PREFIX=/usr/local/redis install 创建/usr/local/redis/etc 目录，将redis.conf 复制过来 123mkdir /usr/local/redis/etcsudo cp redis.conf /usr/local/redic/etc/ 将 Redis 添加系统服务,执行vim /usr/lib/systemd/system/redis-server.service/ 12345678910111213[Unit]Description=The redis-server Process ManagerAfter=syslog.target network.target [Service]Type=simplePIDFile=/var/run/redis.pidExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPID [Install]WantedBy=multi-user.target 执行systemctl start redis-server开启服务 执行 systemctl enable redis-server 设置为开机启动 Redis Cluster 安装///待完成 Redis 配置修改Redis数据保存路径修改1dir xxx(自己想要配置的路径) Redis 持久化策略修改 RDF 默认配置123save 900 1save 300 10save 60 10000 RDF 性能高，但是数据相对不安全，且fork消耗资源大 AOF 默认关闭 修改 appendonly yes 开启 如果开启AOF，更新条件有三种选择appendfsync always 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）appendfsync everysec 没秒同步一次 （折中，默认值）appendfsync no 等操作系统将数据缓存同步到磁盘（快） Redis 数据淘汰策略修改 最大内存占用修改maxmemory 默认值是512M，但是单位是byte，所以为536870912 内存淘汰策略修改maxmemory-policy 默认 noeviction 规则名称 规则说明 noeviction 默认值，不删除只返回错误 volatile-lru 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。 allkeys-lru 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。 allkeys-random 所有key通用; 随机删除一部分 key。 volatile-random 只限于设置了 expire 的部分; 随机删除一部分 key。 volatile-ttl 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。 Redis数据类型 String List Hash Set SortedSet Geo pub/sub HyperLogLog Redis使用场景Redis分布式缓存分布式缓存要注意的问题 缓存雪崩问题 保证缓存的高可用 系统内部最好用ehcache做一个小的缓存（无法做到分布式缓存） 使用hytrix 限流和降级 缓存穿透（恶意请求 查询不存在数据，消耗数据库资源） 将不存在的key放入缓存，存储不存在标识 数据库缓存双写不一致 读的时候先读缓存，没有在读数据库，然后写入缓存 更新的时候，先删除缓存，然后更新数据库 高并发下的读写不一致可以考虑把请求放在内存队列中处理，把对同一个数据的读写进行串行化 分享个缓存的简单demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.Serializable;public class Animal implements Serializable &#123; private Long id; private AnimalType type; private String name; public Animal(Long id, AnimalType type, String name) &#123; this.id = id; this.type = type; this.name = name; &#125; public Animal(AnimalType type, String name) &#123; this.type = type; this.name = name; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public AnimalType getType() &#123; return type; &#125; public void setType(AnimalType type) &#123; this.type = type; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;@FunctionalInterfaceinterface LoadFromDB&lt;T&gt; &#123; T execute(String key);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import java.util.Objects;import java.util.Optional;import java.util.Random;import java.util.concurrent.TimeUnit;public class CacheHelper&lt;T&gt; &#123; private final static String CACHE_PREFIX = "CACHE_PREFIX_"; private final static String MUTEX_PREFIX = "MUTEX_PREFIX_"; private final static Long CACHE_TIMEOUT = 60L * 60 * 8; //second 缓存过期时间 private final static Random random = new Random(); private final static Integer RANDOM_TIME = 60 * 10; //随机时间范围 private final static Long MUTEX_LOCK_TIMEOUT = 60L * 3; private final static Long SHIELD_TIME_OUT = 60l * 10; //防止击穿 private RedisTemplate&lt;String,Object&gt; redisTemplate; private ValueOperations&lt;String, Object&gt; opsForValue; private String cacheKeyPrefix; private String cacheMutexKeyPrefix; public CacheHelper(RedisTemplate&lt;String, Object&gt; redisTemplate,String prefix) &#123; this.redisTemplate = redisTemplate; opsForValue = redisTemplate.opsForValue(); this.cacheKeyPrefix = CACHE_PREFIX + prefix + "_"; this.cacheMutexKeyPrefix = MUTEX_PREFIX + prefix + "_"; &#125; public boolean exit(String key)&#123; Optional&lt;T&gt; optional = (Optional&lt;T&gt;) Optional.of(opsForValue.get(key)); return optional.isPresent(); &#125; public void add(String key,T value)&#123; opsForValue.set(cacheKeyPrefix+key,value,CACHE_TIMEOUT + random.nextInt(RANDOM_TIME),TimeUnit.SECONDS); &#125; public Boolean delete(String key)&#123; return redisTemplate.delete(cacheKeyPrefix + key); &#125; public T get(String key,LoadFromDB&lt;T&gt; action)&#123; //read cache Object o = opsForValue.get(cacheKeyPrefix + key); if(Objects.nonNull(o))&#123; return (T) o; &#125; //加互斥锁，防止高并发击穿 if(opsForValue.setIfAbsent(cacheMutexKeyPrefix+key,1,MUTEX_LOCK_TIMEOUT, TimeUnit.SECONDS))&#123; //load from db T result = action.execute(key); if(Objects.nonNull(result))&#123; add(key,result); return result; &#125; add(key,null,SHIELD_TIME_OUT,TimeUnit.SECONDS); return null; &#125;else&#123; //已存在互斥锁，说明已经有线程添加到缓存 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return get(key,action); &#125; &#125; private void add(String key, Object o, Long shieldTimeOut, TimeUnit seconds) &#123; opsForValue.set(cacheKeyPrefix+key,o,shieldTimeOut,seconds); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import vip.codemonkey.util.utiltest.dto.Animal;@Servicepublic class AnimalService &#123; private final static String PREFIX = "ANIMAL"; @Autowired private RedisTemplate&lt;String,Object&gt; redisTemplate; private CacheHelper&lt;Animal&gt; getCacheHelper()&#123; return new CacheHelper&lt;Animal&gt;(redisTemplate,PREFIX); &#125; public void add(Animal animal)&#123; //insert to db ... // add cache getCacheHelper().add(animal.getId().toString(),animal); &#125; public void update(Animal animal)&#123; //删除缓存 getCacheHelper().delete(animal.getId().toString()); //update db &#125; public Animal get(Long id)&#123; return getCacheHelper().get(id.toString(),(key) -&gt;&#123; return load(Long.parseLong(key)); &#125;); &#125; private Animal load(Long id)&#123; return null; &#125;&#125; Redis节点性能测试 100个连接 10000个请求redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 10000 测试存取大小为100字节的数据的性能redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100 Redis分布式锁分布式锁要解决的问题 互斥性 同一时间只能有一个客户端获取到锁 安全性 锁的释放只能由持有该锁的客户端释放 死锁 容错 由于redis提供的所有api都是原子的，所以要保证锁的原子性，只要上锁和释放锁的操作只调用一个api或在同一个redis任务里执行set KEY VALUE ex SECOND nx 分享个分布式锁的代码锁对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.UUID;public class RedisLock &#123; private String lockKey; /** * 是否到获取锁 */ private Boolean acquired; /** * 确保锁的安全性，避免非持有者释放该锁 */ private String check; /** * 锁持有时间，为避免死锁，到期自动释放，默认0.5秒 */ private Long heldTimeInterval; public RedisLock(String lockKey)&#123; this(lockKey,false); &#125; public RedisLock(String lockKey,Boolean acquired) &#123; this(lockKey,acquired,500L ); &#125; public RedisLock(String lockKey,Long heldTimeInterval) &#123; this(lockKey,false,heldTimeInterval ); &#125; public RedisLock(String lockKey,Boolean acquired,Long heldTimeInterval) &#123; this.acquired = acquired; this.check = UUID.randomUUID().toString()+":"+lockKey; this.heldTimeInterval = heldTimeInterval; this.lockKey = lockKey; &#125; public String getLockKey() &#123; return lockKey; &#125; public void setLockKey(String lockKey) &#123; this.lockKey = lockKey; &#125; public Boolean getAcquired() &#123; return acquired; &#125; public void setAcquired(Boolean acquired) &#123; this.acquired = acquired; &#125; public String getCheck() &#123; return check; &#125; public void setCheck(String check) &#123; this.check = check; &#125; public Long getHeldTimeInterval() &#123; return heldTimeInterval; &#125; public void setHeldTimeInterval(Long heldTimeInterval) &#123; this.heldTimeInterval = heldTimeInterval; &#125;&#125; 分布式锁接口1234567891011121314public interface DistributedLock &#123; RedisLock lock(String lockKey); RedisLock lock(String lockKey,Long heldTimeInterval); RedisLock tryLock(String lockKey); RedisLock tryLock(String lockKey, long time); RedisLock tryLock(String lockKey, long time,Long heldTimeInterval); void unLock(RedisLock lock);&#125; 分布式锁实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.data.redis.core.script.RedisScript;import org.springframework.stereotype.Component;import java.util.Arrays;import java.util.Objects;import java.util.concurrent.TimeUnit;@Componentpublic class DistributedLockImpl implements DistributedLock&#123; private final static String LOCK_PREFIX = "DISTRIBUTED_LOCK_"; @Autowired StringRedisTemplate redisTemplate; private void lock(RedisLock redisLock)&#123; while(!redisTemplate.boundValueOps(LOCK_PREFIX + redisLock.getLockKey()).setIfAbsent(redisLock.getCheck(), redisLock.getHeldTimeInterval(), TimeUnit.MILLISECONDS))&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; redisLock.setAcquired(true); &#125; @Override public RedisLock lock(String lockKey) &#123; RedisLock redisLock = new RedisLock(lockKey); lock(redisLock); return redisLock; &#125; @Override public RedisLock lock(String lockKey, Long heldTimeInterval) &#123; RedisLock redisLock = new RedisLock(lockKey,heldTimeInterval); lock(redisLock); return redisLock; &#125; @Override public RedisLock tryLock(String lockKey) &#123; RedisLock redisLock = new RedisLock(lockKey); redisLock.setAcquired(redisTemplate.boundValueOps(LOCK_PREFIX + redisLock.getLockKey()).setIfAbsent(redisLock.getCheck(), redisLock.getHeldTimeInterval(), TimeUnit.MILLISECONDS)); return redisLock; &#125; @Override public RedisLock tryLock(String lockKey, long time) &#123; RedisLock redisLock = new RedisLock(lockKey); return tryLock(lockKey,time,redisLock.getHeldTimeInterval()); &#125; @Override public RedisLock tryLock(String lockKey, long time, Long heldTimeInterval) &#123; Long begin = System.currentTimeMillis(); RedisLock redisLock = new RedisLock(lockKey,heldTimeInterval); Boolean acquired; while(!(acquired = redisTemplate.boundValueOps(LOCK_PREFIX + lockKey).setIfAbsent(redisLock.getCheck(),redisLock.getHeldTimeInterval(),TimeUnit.MILLISECONDS)) &amp;&amp; System.currentTimeMillis() - time &gt;= begin )&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; redisLock.setAcquired(acquired); return redisLock; &#125; @Override public void unLock(RedisLock lock) &#123; String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"; RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript(script ,Long.class); Long result = redisTemplate.execute(redisScript, Arrays.asList(LOCK_PREFIX+lock.getLockKey()), lock.getCheck()); System.out.println("释放结果 "+result); if(Objects.equals(result,1L))&#123; System.out.println("释放锁成功"); &#125;else &#123; System.out.println("释放锁失败"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>工具使用</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 使用PlantUML 绘制UML图]]></title>
    <url>%2F2019%2F03%2F05%2FMarkdown_UML_Plant_UML%2F</url>
    <content type="text"><![CDATA[PlantUML简介PlantUML 是一个开源项目，支持快速绘制时序图、用例图、类图、活动图、组建图、状态图、对象图、部署图、定时图这些UML图，同时还支持线框图形界面、架构图、规范和描述语言(SDL)、Ditaa diagram、甘特图、思维导图等非UML图。 UML类图使用类图中的关系 泛化|继承|扩展语法：&lt;|--效果展示： 123@startumlFather &lt;|-- Son@enduml 实现语法：&lt;|.. 效果展示： 1234@startumlinterface ListList &lt;|.. ArrayList@enduml 依赖语法：&lt;..效果展示： 123@startumlClassA &lt;.. ClassB@enduml 描述：对象之间最弱的一种关联关系，是临时性关系。代码中一般指由局部变量,函数参数，返回值建立的对其他对象的调用关系。在类图中使用带箭头的虚线表示。箭头从使用类指向被依赖类。 关联语法：&lt;--效果展示： 123@startumlClassA &lt;-- ClassB@enduml 描述：关联关系体现的是两个类，或者类与接口之间的强依赖关系，这种关系很强烈，比依赖更强，不是偶然性的，也不是临时性的，而是一种长期性，相对平等的关系，表现在代码层面，为被关联的类B以类属性的形式出现在类A中，也可能是关联类A引用了被关联类B的全局变量。 聚合语法：--o效果展示： 123@startumlClassA --o ClassB@enduml 描述：表示has-a的关系，是一种不稳定的包含关系。较强于一般关联，有整体与局部的关系，没有了整体，局部可以单独存在。在类图中用空心菱形表示。菱形从局部指向整体。 组合语法：--*效果展示： 123@startumlClassA --* ClassB@enduml 描述：表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系，整体和部分不可分。在类图中用实心菱形表示，菱形从局部指向整体。 定义可访问性 Character Icon for field Icon for method Visibility - □ ■ private # ◇ ◆ protected ~ △ ▲ package private + ○ ● public]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>UML</tag>
        <tag>类图</tag>
      </tags>
  </entry>
</search>
